// Generated by CoffeeScript 1.8.0
(function() {
  var CONSOLE_TAG, eventNames, states, wrapError;

  CONSOLE_TAG = "backbone-dualStorage";

  states = {
    SYNCHRONIZED: 'SYNCHRONIZED',
    SYNCHRONIZING: 'SYNCHRONIZING',
    UPDATE_FAILED: 'UPDATE_FAILED',
    DELETE_FAILED: 'DELETE_FAILED'
  };

  eventNames = {
    LOCAL_SYNC_FAIL: 'LOCAL_SYNC_FAIL',
    LOCAL_SYNC_SUCCESS: 'LOCAL_SYNC_SUCCESS',
    REMOTE_SYNC_FAIL: 'REMOTE_SYNC_FAIL',
    REMOTE_SYNC_SUCCESS: 'REMOTE_SYNC_SUCCESS',
    SYNCHRONIZED: 'SYNCHRONIZED'
  };

  wrapError = function(model, options) {
    var error;
    error = options.error;
    return options.error = function(resp) {
      if (error) {
        error(model, resp, options);
      }
      return model.trigger('error', model, resp, options);
    };
  };

  Backbone.DualModel = Backbone.Model.extend({
    states: states,
    isDelayed: function() {
      var _ref;
      return (_ref = this.get('status')) === this.states.DELETE_FAILED || _ref === this.states.UPDATE_FAILED;
    }
  });

  Backbone.DualCollection = Backbone.Collection.extend({
    states: states,
    eventNames: eventNames,
    merge: function(newData) {
      return newData;
    },
    firstSync: function(options) {
      var fetchSuccess, originalSuccess, syncSuccess;
      if (options == null) {
        options = {};
      }
      originalSuccess = options.success || $.noop;
      syncSuccess = (function(_this) {
        return function(response) {
          var data, method;
          data = _this.merge(_this.parse(response));
          method = options.reset ? 'reset' : 'set';
          _this[method](data, options);
          originalSuccess(_this, data, options);
          _this.trigger('sync', _this, data, options);
          return wrapError(_this, options);
        };
      })(this);
      fetchSuccess = (function(_this) {
        return function() {
          options.success = syncSuccess;
          return Backbone.ajaxSync('read', _this, options);
        };
      })(this);
      return this.fetch({
        success: fetchSuccess
      });
    },
    removeGarbage: function() {
      var deferred, idsForRemove, options, status;
      deferred = new $.Deferred();
      idsForRemove = [];
      status = this.states.SYNCHRONIZING;
      options = {
        onEnd: (function(_this) {
          return function() {
            return _this.indexedDB.removeBatch(idsForRemove, (function() {
              return deferred.resolve(arguments);
            }), (function() {
              return deferred.reject(arguments);
            }));
          };
        })(this)
      };
      this.indexedDB.iterate(function(data) {
        if (data.status === status) {
          return idsForRemove.push(data.local_id);
        }
      }, options);
      return deferred.promise();
    },
    getDelayedData: function(status) {
      var data, deferred, keyRange, options;
      deferred = new $.Deferred();
      data = [];
      keyRange = this.indexedDB.makeKeyRange({
        lower: status,
        upper: status
      });
      options = {
        index: 'status',
        keyRange: keyRange,
        onEnd: function() {
          return deferred.resolve(data);
        }
      };
      this.indexedDB.iterate(function(item) {
        return data.push(item);
      }, options);
      return deferred.promise();
    },
    save: function() {
      var deferred;
      deferred = new $.Deferred();
      this.indexedDB.saveAll((function() {
        return deferred.resolve();
      }), (function() {
        return deferred.reject();
      }));
      return deferred.promise();
    },
    markAsSynchronizing: function() {
      var models;
      models = this.filter(function(item) {
        return item.isDelayed();
      });
      models = _.map(models, (function(_this) {
        return function(model) {
          model.set({
            'status': _this.states.SYNCHRONIZING
          });
          return model.save();
        };
      })(this));
      return $.when.apply($, models);
    }
  });

}).call(this);

//# sourceMappingURL=backbone.dualstorage.js.map
