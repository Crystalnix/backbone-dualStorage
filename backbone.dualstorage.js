// Generated by CoffeeScript 1.8.0
(function() {
  var BackboneIndexedDB;

  BackboneIndexedDB = (function() {
    BackboneIndexedDB.prototype.states = {
      SYNCHRONIZED: 'SYNCHRONIZED',
      SYNCHRONIZING: 'SYNCHRONIZING',
      UPDATE_FAILED: 'UPDATE_FAILED',
      DELETE_FAILED: 'DELETE_FAILED'
    };

    BackboneIndexedDB.prototype.eventNames = {
      LOCAL_SYNC_FAIL: 'LOCAL_SYNC_FAIL',
      LOCAL_SYNC_SUCCESS: 'LOCAL_SYNC_SUCCESS',
      REMOTE_SYNC_FAIL: 'REMOTE_SYNC_FAIL',
      REMOTE_SYNC_SUCCESS: 'REMOTE_SYNC_SUCCESS',
      SYNCHRONIZED: 'SYNCHRONIZED'
    };

    function BackboneIndexedDB(options, parent) {
      var defaultErrorHandler, defaultReadyHandler, defaults;
      this.parent = parent;
      defaultReadyHandler = (function(_this) {
        return function() {
          return _this.parent.trigger("idb:ready", _this);
        };
      })(this);
      defaultErrorHandler = function(error) {
        throw error;
      };
      defaults = {
        storeName: "Store",
        storePrefix: "",
        dbVersion: 1,
        keyPath: "local_id",
        autoIncrement: true,
        onStoreReady: defaultReadyHandler,
        onError: defaultErrorHandler,
        indexes: [
          {
            name: 'id',
            keyPath: 'id',
            unique: true,
            multiEntry: false
          }
        ]
      };
      options = _.defaults(options || {}, defaults);
      this.dbName = options.storePrefix + options.storeName;
      this.store = new IDBStore(options);
    }

    BackboneIndexedDB.prototype.wrapStoreCallForDeferred = function(method, data) {
      var deferred, fail, success;
      deferred = new $.Deferred();
      success = function(result) {
        return deferred.resolve(result);
      };
      fail = function(result) {
        return deferred.reject(result);
      };
      method.call(this.store, data, success, fail);
      return deferred.promise();
    };

    BackboneIndexedDB.prototype.create = function(data) {
      return this.wrapStoreCallForDeferred(this.store.put, data);
    };

    BackboneIndexedDB.prototype.update = function(data) {
      return this.wrapStoreCallForDeferred(this.store.put, data);
    };

    BackboneIndexedDB.prototype.read = function(id) {
      return this.wrapStoreCallForDeferred(this.store.get, id);
    };

    BackboneIndexedDB.prototype.destroy = function(id) {
      return this.wrapStoreCallForDeferred(this.store.remove, id);
    };

    BackboneIndexedDB.prototype.saveAll = function(data) {
      return this.wrapStoreCallForDeferred(this.store.putBatch, data);
    };

    BackboneIndexedDB.prototype.getAll = function() {
      return this.wrapStoreCallForDeferred(this.store.getAll);
    };

    BackboneIndexedDB.prototype.deleteDatabase = function() {
      return this.wrapStoreCallForDeferred(this.store.deleteDatabase);
    };

    BackboneIndexedDB.prototype.merge = function(oldData, newData) {
      return newData;
    };

    BackboneIndexedDB.prototype.asd = {
      'read': ['fetchRemote', 'fetchLocal', 'merge', 'saveInLocal']
    };

    BackboneIndexedDB.prototype.flagsForFailedRemoteSync = {
      'read': void 0,
      'create': BackboneIndexedDB.states.UPDATE_FAILED,
      'update': BackboneIndexedDB.states.UPDATE_FAILED,
      'delete': BackboneIndexedDB.states.DELETE_FAILED
    };

    BackboneIndexedDB.prototype.removeGarbage = function() {
      var deferred, idsForRemove, options, status;
      deferred = new $.Deferred();
      idsForRemove = [];
      status = this.states.SYNCHRONIZING;
      options = {
        onEnd: (function(_this) {
          return function() {
            return _this.store.removeBatch(idsForRemove, (function() {
              return deferred.resolve(arguments);
            }), (function() {
              return deferred.reject(arguments);
            }));
          };
        })(this)
      };
      this.store.iterate(function(data) {
        if (data.status === status) {
          return idsForRemove.push(data.local_id);
        }
      }, options);
      return deferred.promise();
    };

    BackboneIndexedDB.prototype.sync = function(method, model, options) {
      var data, db, event, localMethod, merge, originalError, originalSuccess;
      event = _.extend({}, Backbone.Events);
      originalSuccess = options.success || $.noop;
      originalError = options.error || $.noop;
      model.status = this.states.SYNCHRONIZING;
      merge = model.merge || this.merge;
      options.error = (function(_this) {
        return function(response) {
          model.status = _this.flagsForFailedRemoteSync[method];
          return _this.update(model.toJSON()).done(function() {
            event.trigger(_this.eventNames.REMOTE_SYNC_FAIL, response);
            originalError.apply(_this, arguments);
            return event.trigger(_this.eventNames.SYNCHRONIZED);
          });
        };
      })(this);
      options.success = (function(_this) {
        return function(response) {
          var data;
          model.status = _this.states.SYNCHRONIZED;
          data = merge.call(_this, model.toJSON(), response);
          return _this.update(data).done(function() {
            event.trigger(_this.eventNames.REMOTE_SYNC_SUCCESS, _.extend({}, response));
            originalSuccess.call(_this, data);
            return _this.removeGarbage().done(function() {
              return event.trigger(_this.eventNames.SYNCHRONIZED);
            });
          });
        };
      })(this);
      db = model.indexedDB || model.collection.indexedDB;
      localMethod = method;
      if (method === 'read' && !model.id) {
        localMethod = 'getAll';
      }
      if (method === 'read' || method === 'destroy') {
        data = model.id;
      } else if (method === 'create' || method === 'update') {
        data = model.toJSON();
        data.status = model.status;
      }
      db[method](data).fail((function(_this) {
        return function(result) {
          return event.trigger(_this.eventNames.LOCAL_SYNC_FAIL, result);
        };
      })(this)).done((function(_this) {
        return function(result) {
          return event.trigger(_this.eventNames.LOCAL_SYNC_SUCCESS, result);
        };
      })(this)).done((function(_this) {
        return function(result) {
          if (!options.attrs && model.getDataForRemoteSync) {
            options.attrs = model.getDataForRemoteSync();
          }
          return Backbone.sync.call(_this, method, model, options);
        };
      })(this));
      return event;
    };

    return BackboneIndexedDB;

  })();

}).call(this);

//# sourceMappingURL=backbone.dualstorage.js.map
